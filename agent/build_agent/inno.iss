; Script generated by the Inno Setup Script Wizard.
; SEE THE DOCUMENTATION FOR DETAILS ON CREATING INNO SETUP SCRIPT FILES!

#define MyAppName "CMSAgent"
#define MyAppVersion "1.0.2"
#define MyAppPublisher "Your Company Name"
#define MyAppURL "https://www.yourcompany.com/"
#define MyAppExeName "agent.exe"
#define MyUpdaterExeName "updater.exe"

[Setup]
; NOTE: The value of AppId uniquely identifies this application.
; Do not use the same AppId value in installers for other applications.
AppId={{AUTO_GUID}}
AppName={#MyAppName}
AppVersion={#MyAppVersion}
;AppVerName={#MyAppName} {#MyAppVersion}
AppPublisher={#MyAppPublisher}
AppPublisherURL={#MyAppURL}
AppSupportURL={#MyAppURL}
AppUpdatesURL={#MyAppURL}
DefaultDirName={autopf64}\CMSAgent
DefaultGroupName=CMSAgent
DisableProgramGroupPage=yes
; Always require admin privileges for service installation
PrivilegesRequired=admin
OutputBaseFilename=CMSAgent_Setup_{#MyAppVersion}
OutputDir=.
; ThÃªm icon cho file setup
SetupIconFile=icon.ico
Compression=lzma
SolidCompression=yes
WizardStyle=modern
UninstallDisplayIcon={app}\agent\{#MyAppExeName}
; Set service recovery options through registry
; Include this line to create uninstall registry info
Uninstallable=yes
; Create ProgramData directories with proper permissions
ChangesEnvironment=yes

; Include custom dialog for room configuration
#include "scripts\RoomConfigPage.iss"

[Languages]
Name: "english"; MessagesFile: "compiler:Default.isl"

[Messages]
; Custom messages for service setup
ServiceInstallFailed=Failed to install the service. Please check logs for details.
ServiceStartFailed=Failed to start the service. Please check logs for details.
ServiceConfigurationFailed=Failed to configure the agent. Please check logs for details.

[Tasks]
Name: "desktopicon"; Description: "{cm:CreateDesktopIcon}"; GroupDescription: "{cm:AdditionalIcons}"; Flags: unchecked

[Files]
Source: "dist_agent\agent.exe"; DestDir: "{app}\agent"; Flags: ignoreversion
Source: "dist_agent\config\agent_config.json"; DestDir: "{app}\agent\config"; Flags: ignoreversion
Source: "dist_updater\updater.exe"; DestDir: "{app}\updater"; Flags: ignoreversion
; NOTE: Don't use "Flags: ignoreversion" on any shared system files

[Icons]
Name: "{group}\{#MyAppName}"; Filename: "{app}\agent\{#MyAppExeName}"
Name: "{group}\Force Restart Agent"; Filename: "{app}\agent\{#MyAppExeName}"; Parameters: "force-restart"
Name: "{group}\{cm:UninstallProgram,{#MyAppName}}"; Filename: "{uninstallexe}"
Name: "{autodesktop}\{#MyAppName}"; Filename: "{app}\agent\{#MyAppExeName}"; Tasks: desktopicon

[Dirs]
; Create ProgramData directory structure with proper permissions
Name: "{commonappdata}\CMSAgent"; Permissions: everyone-full
Name: "{commonappdata}\CMSAgent\logs"; Permissions: everyone-full
Name: "{commonappdata}\CMSAgent\error_reports"; Permissions: everyone-full
Name: "{commonappdata}\CMSAgent\config"; Permissions: everyone-full
Name: "{commonappdata}\CMSAgent\cache"; Permissions: everyone-full
Name: "{commonappdata}\CMSAgent\updates"; Permissions: everyone-full

[Run]
; Install the agent service
Filename: "{app}\agent\{#MyAppExeName}"; Parameters: "install"; WorkingDir: "{app}\agent"; StatusMsg: "Installing service..."; Flags: runhidden; Check: ShouldInstallService

; Start the agent service
Filename: "{app}\agent\{#MyAppExeName}"; Parameters: "start"; WorkingDir: "{app}\agent"; StatusMsg: "Starting service..."; Flags: runhidden; Check: ShouldStartService

[UninstallRun]
; Stop the service before uninstalling
Filename: "{app}\agent\{#MyAppExeName}"; Parameters: "stop"; WorkingDir: "{app}\agent"; StatusMsg: "Stopping service..."; Flags: runhidden

; Remove the service
Filename: "{app}\agent\{#MyAppExeName}"; Parameters: "remove"; WorkingDir: "{app}\agent"; StatusMsg: "Removing service..."; Flags: runhidden

[UninstallDelete]
Type: filesandordirs; Name: "{app}\agent"
Type: filesandordirs; Name: "{app}\updater"
; Only delete root directory if it's empty
Type: dirifempty; Name: "{app}"
; Ask the user if they want to delete data files in ProgramData
Type: filesandordirs; Name: "{commonappdata}\CMSAgent"; Check: ShouldDeleteDataFiles

[Registry]
; Configure service recovery options
Root: HKLM; Subkey: "SYSTEM\CurrentControlSet\Services\CMSAgentService"; ValueType: dword; ValueName: "FailureActions"; ValueData: "1"; Flags: uninsdeletevalue
Root: HKLM; Subkey: "SYSTEM\CurrentControlSet\Services\CMSAgentService"; ValueType: dword; ValueName: "FailureCommand"; ValueData: """{app}\agent\{#MyAppExeName}"" restart"; Flags: uninsdeletevalue
Root: HKLM; Subkey: "SYSTEM\CurrentControlSet\Services\CMSAgentService"; ValueType: dword; ValueName: "FailureResetPeriod"; ValueData: "86400"; Flags: uninsdeletevalue

[Code]
var
  ConfigurePage: TInputQueryWizardPage;
  ConfigureSuccess: Boolean;
  InstallSuccess: Boolean;
  StartSuccess: Boolean;
  DataDirDelete: Boolean;
  UniqueAgentIDForMFA: String;

// Forward declarations
function InitializeSetup(): Boolean;
function ShouldInstallService(): Boolean;
function ShouldStartService(): Boolean;
function GetRoomName(Param: String): String;
function GetComputerName(Param: String): String;
function GetPosX(Param: String): String;
function GetPosY(Param: String): String;
function ShouldDeleteDataFiles(): Boolean;

// Initialize setup and create custom pages
function InitializeSetup(): Boolean;
begin
  // Initialize success flags
  ConfigureSuccess := False;
  InstallSuccess := True;
  StartSuccess := True;
  DataDirDelete := False;
  UniqueAgentIDForMFA := '';
  
  Result := True;
end;

// Create the room configuration page
procedure InitializeWizard;
begin
  // Create room configuration page
  ConfigurePage := CreateInputQueryPage(wpWelcome,
    'Room Configuration',
    'Please enter the room details for this computer',
    'This information is required to identify the computer in the management system.');

  // Add fields to the page
  ConfigurePage.Add('Room Name:', False);
  ConfigurePage.Add('Computer Name:', False);
  ConfigurePage.Add('Position X (optional):', False);
  ConfigurePage.Add('Position Y (optional):', False);
  
  // Set default values for position
  ConfigurePage.Values[2] := '0';
  ConfigurePage.Values[3] := '0';
end;

// Return room name for configuration
function GetRoomName(Param: String): String;
begin
  Result := ConfigurePage.Values[0];
end;

// Return computer name for configuration
function GetComputerName(Param: String): String;
begin
  Result := ConfigurePage.Values[1];
end;

// Return position X for configuration
function GetPosX(Param: String): String;
begin
  if ConfigurePage.Values[2] = '' then
    Result := '0'
  else
    Result := ConfigurePage.Values[2];
end;

// Return position Y for configuration
function GetPosY(Param: String): String;
begin
  if ConfigurePage.Values[3] = '' then
    Result := '0'
  else
    Result := ConfigurePage.Values[3];
end;

// Install service step validation
function ShouldInstallService(): Boolean;
begin
  Result := ConfigureSuccess and InstallSuccess;
end;

// Start service step validation
function ShouldStartService(): Boolean;
begin
  Result := ConfigureSuccess and InstallSuccess and StartSuccess;
end;

// Helper function to execute agent commands and parse their output
function ExecAgentCommand(AgentParams: String; var OutStatus, OutMessage, OutUniqueID: String): Boolean;
var
  AgentAppPath: String;
  TempOutputFile: String;
  CmdResultCode: Integer;
  ResponseLines: TArrayOfString;
  i: Integer;
  FullCommand: String;
begin
  AgentAppPath := ExpandConstant('{app}\agent\{#MyAppExeName}');
  TempOutputFile := ExpandConstant('{tmp}\agent_setup_response.txt');
  DeleteFile(TempOutputFile); // Ensure clean state

  // Agent command is expected to write STATUS:, MESSAGE:, UNIQUE_AGENT_ID: to TempOutputFile
  FullCommand := AgentParams + ' --output-file "' + TempOutputFile + '"';

  Log(Format('Executing agent command: %s %s', [AgentAppPath, FullCommand]));

  if not Exec(AgentAppPath, FullCommand, ExpandConstant('{app}\agent'), SW_HIDE, ewWaitUntilTerminated, CmdResultCode) then
  begin
    OutStatus := 'EXEC_FAILED';
    OutMessage := 'Failed to execute agent command: ' + AgentAppPath;
    Log(OutMessage);
    Result := False;
    Exit;
  end;

  Log(Format('Agent command exited with code: %d', [CmdResultCode]));

  if not LoadStringsFromFile(TempOutputFile, ResponseLines) then
  begin
    OutStatus := 'READ_RESPONSE_FAILED';
    if CmdResultCode = 0 then
      OutMessage := 'Failed to read response from agent command, though it exited successfully.'
    else
      OutMessage := Format('Failed to read response and agent command exited with error %d.', [CmdResultCode]);
    Log(OutMessage);
    DeleteFile(TempOutputFile);
    Result := False;
    Exit;
  end;

  DeleteFile(TempOutputFile); // Clean up temp file

  OutStatus := '';
  OutMessage := '';
  OutUniqueID := '';

  for i := 0 to GetArrayLength(ResponseLines) - 1 do
  begin
    Log(Format('Response Line %d: %s', [i, ResponseLines[i]]));
    if Pos('STATUS:', Uppercase(ResponseLines[i])) = 1 then
      OutStatus := Trim(Copy(ResponseLines[i], Length('STATUS:') + 1, Length(ResponseLines[i]) - Length('STATUS:')))
    else if Pos('MESSAGE:', Uppercase(ResponseLines[i])) = 1 then
      OutMessage := Trim(Copy(ResponseLines[i], Length('MESSAGE:') + 1, Length(ResponseLines[i]) - Length('MESSAGE:')))
    else if Pos('UNIQUE_AGENT_ID:', Uppercase(ResponseLines[i])) = 1 then
      OutUniqueID := Trim(Copy(ResponseLines[i], Length('UNIQUE_AGENT_ID:') + 1, Length(ResponseLines[i]) - Length('UNIQUE_AGENT_ID:')));
  end;
  
  Log(Format('Parsed - Status: %s, Message: %s, UniqueID: %s', [OutStatus, OutMessage, OutUniqueID]));

  // If agent process itself had an error code, reflect it if no status was parsed
  if (CmdResultCode <> 0) and (OutStatus = '') then
  begin
    OutStatus := 'AGENT_ERROR';
    if OutMessage = '' then OutMessage := Format('Agent command failed with exit code %d and did not provide a status.', [CmdResultCode]);
  end
  else if (CmdResultCode = 0) and (OutStatus = '') then // Exited OK but no status
  begin
    OutStatus := 'NO_STATUS_RETURNED';
    OutMessage := 'Agent command completed but did not return a status.';
  end;

  Result := True; // Indicates execution and parsing attempt, caller must check OutStatus
end;

// Check for room name validation
function NextButtonClick(CurPageID: Integer): Boolean;
var
  RoomName, ComputerName, PosX, PosY, AgentCmdParams, ServerResponseStatus, ServerResponseMessage: String;
  MFAInputCode, MfaCmdParams, MfaServerStatus, MfaServerMessage, TempUniqueID : String;
begin
  Result := True; // Assume success unless set to False

  if CurPageID = ConfigurePage.ID then
  begin
    ConfigureSuccess := False; // Reset before attempt

    // Validate room configuration fields (client-side)
    RoomName := ConfigurePage.Values[0];
    ComputerName := ConfigurePage.Values[1];

    if RoomName = '' then
    begin
      MsgBox('Room name cannot be empty. Please enter a valid room name.', mbError, MB_OK);
      Result := False; Exit;
    end;
    if ComputerName = '' then
    begin
      MsgBox('Computer name cannot be empty. Please enter a valid computer name.', mbError, MB_OK);
      Result := False; Exit;
    end;
    if (ConfigurePage.Values[2] <> '') and not IsInt(ConfigurePage.Values[2]) then
    begin
      MsgBox('Position X must be a valid number.', mbError, MB_OK);
      Result := False; Exit;
    end;
    if (ConfigurePage.Values[3] <> '') and not IsInt(ConfigurePage.Values[3]) then
    begin
      MsgBox('Position Y must be a valid number.', mbError, MB_OK);
      Result := False; Exit;
    end;

    PosX := GetPosX(''); // Uses existing helper which defaults to '0'
    PosY := GetPosY(''); // Uses existing helper which defaults to '0'

    // Step 1: Initial identification call
    AgentCmdParams := Format('setup-identify --room "%s" --computer-name "%s" --pos-x %s --pos-y %s', [RoomName, ComputerName, PosX, PosY]);
    if ExecAgentCommand(AgentCmdParams, ServerResponseStatus, ServerResponseMessage, UniqueAgentIDForMFA) then
    begin
      Log(Format('Initial identify response - Status: %s, Message: %s, UniqueIDForMFA: %s', [ServerResponseStatus, ServerResponseMessage, UniqueAgentIDForMFA]));
      if ServerResponseStatus = 'mfa_required' then
      begin
        if InputQuery('Multi-Factor Authentication Required', ServerResponseMessage + #13#10 + 'Please enter the verification code:', MFAInputCode) then
        begin
          if MFAInputCode = '' then
          begin
            MsgBox('MFA code cannot be empty.', mbError, MB_OK);
            Result := False; Exit;
          end;
          
          // Step 2: MFA verification call
          // Ensure UniqueAgentIDForMFA was received
          if UniqueAgentIDForMFA = '' then
          begin
             MsgBox('MFA is required, but Unique Agent ID was not provided by the agent for MFA verification. Cannot proceed.', mbError, MB_OK);
             Result := False; Exit;
          end;

          MfaCmdParams := Format('setup-verify-mfa --mfa-code "%s" --unique-agent-id "%s"', [MFAInputCode, UniqueAgentIDForMFA]);
          if ExecAgentCommand(MfaCmdParams, MfaServerStatus, MfaServerMessage, TempUniqueID) then // TempUniqueID not used here
          begin
            Log(Format('MFA verify response - Status: %s, Message: %s', [MfaServerStatus, MfaServerMessage]));
            if MfaServerStatus = 'success' then
            begin
              ConfigureSuccess := True;
              MsgBox('Agent configured successfully with MFA.', mbInformation, MB_OK);
              Result := True; // Proceed to next setup page
            end
            else // MFA verification failed
            begin
              MsgBox(Format('MFA Verification Failed: %s (%s)', [MfaServerMessage, MfaServerStatus]), mbError, MB_OK);
              Result := False; // Stay on config page or handle as error
            end;
          end
          else // ExecAgentCommand for MFA failed
          begin
            MsgBox(Format('Failed to execute MFA verification command. %s (%s)', [MfaServerMessage, MfaServerStatus]), mbError, MB_OK);
            Result := False;
          end;
        end
        else // User cancelled MFA input
        begin
          MsgBox('MFA code is required to complete the installation. Configuration aborted.', mbWarning, MB_OK);
          Result := False; // Stay on config page or handle as error
        end;
      end
      else if ServerResponseStatus = 'success' then
      begin
        ConfigureSuccess := True;
        MsgBox('Agent configured successfully.', mbInformation, MB_OK);
        Result := True; // Proceed to next setup page
      end
      else if ServerResponseStatus = 'position_error' then
      begin
        MsgBox(Format('Configuration Error: %s Please correct the details and try again. (%s)', [ServerResponseMessage, ServerResponseStatus]), mbError, MB_OK);
        Result := False; // Stay on config page for correction
      end
      else // Other errors from initial identify (error, agent_error, no_status_returned etc.)
      begin
        MsgBox(Format('Agent configuration failed: %s (%s)', [ServerResponseMessage, ServerResponseStatus]), mbError, MB_OK);
        Result := False;
      end;
    end
    else // ExecAgentCommand for initial identify failed
    begin
      MsgBox(Format('Failed to execute agent configuration command. %s (%s)', [ServerResponseMessage, ServerResponseStatus]), mbError, MB_OK);
      Result := False;
    end;
  end else begin
    Result := True; // For other pages, default behavior
  end;
end;

// Simplified CurStepChanged, or it can be removed if not needed for other post-install tasks.
procedure CurStepChanged(CurStep: TSetupStep);
begin
  if CurStep = ssPostInstall then
  begin
    Log('CurStepChanged: ssPostInstall.');
    if not ConfigureSuccess then
    begin
      Log('Agent configuration was not successful. Service installation/start might be skipped based on their "Check" conditions.');
    end;
  end;
end;

// Ask if user wants to delete data files during uninstall
function InitializeUninstall(): Boolean;
begin
  Result := True;
  
  // Ask if user wants to delete data files in ProgramData
  if MsgBox('Do you want to delete all agent data files? This includes logs and configuration files.', mbConfirmation, MB_YESNO) = IDYES then
    DataDirDelete := True
  else
    DataDirDelete := False;
end;

// Check if data directory should be deleted
function ShouldDeleteDataFiles(): Boolean;
begin
  Result := DataDirDelete;
end;